---
phase: 01-offline-mode
plan: 03
type: execute
wave: 3
depends_on:
  - 01-02
files_modified:
  - src/renderer/app.ts
autonomous: false

requirements:
  - OFFL-02
  - OFFL-03
  - OFFL-04

must_haves:
  truths:
    - "When a live fetch fails and cache exists, the widget shows cached usage data (progress bars, timers) instead of an error"
    - "Status bar reads 'Offline · Last updated X minutes ago' when showing cached data, using the original fetch timestamp (not current time)"
    - "When in offline mode, the widget retries fetchUsageData every 5 minutes (same as normal refresh interval)"
    - "When a retry succeeds, isOffline clears, status bar reverts to normal 'Refreshed X minutes ago', and the normal auto-refresh resumes"
    - "Successful normal fetches always clear isOffline and stop the retry interval, even when user manually refreshes while offline"
    - "Cold start with no network and no cache shows the existing login/error screen unchanged (no empty progress bars)"
  artifacts:
    - path: "src/renderer/app.ts"
      provides: "Offline mode state, fallback display, status text, retry loop"
      contains: "isOffline"
  key_links:
    - from: "src/renderer/app.ts"
      to: "window.electronAPI.getCachedUsage"
      via: "called in fetchUsageData catch block on non-auth error"
      pattern: "getCachedUsage"
    - from: "src/renderer/app.ts"
      to: "updateStatusText"
      via: "isOffline flag checked inside updateStatusText to prepend 'Offline · '"
      pattern: "isOffline"
    - from: "src/renderer/app.ts"
      to: "offlineRetryInterval"
      via: "startOfflineRetry / stopOfflineRetry manage setInterval for 5-min retry"
      pattern: "offlineRetryInterval"
---

<objective>
Implement all renderer-side offline mode logic in app.ts: offline state tracking, cached data fallback display, status bar "Offline · Last updated X ago" indicator, 5-minute retry polling loop, and clean recovery when connectivity returns.

Purpose: This is the user-facing behaviour of the entire offline mode feature. All user-visible requirements (OFFL-02, OFFL-03, OFFL-04) are fulfilled here.
Output: app.ts extended with isOffline flag, startOfflineRetry/stopOfflineRetry functions, updated fetchUsageData catch block, updated updateStatusText, and clearance of offline state on success.
</objective>

<execution_context>
@/Users/jamesbolton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesbolton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/renderer/app.ts
@src/shared/ipc-types.ts
@.planning/phases/01-offline-mode/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement offline state, retry loop, and fallback display in app.ts</name>
  <files>src/renderer/app.ts</files>
  <action>
    Make five targeted changes to app.ts. Read the full file before editing; use the line references from the research to locate the correct positions.

    **Change 1 — Add offline state variables** (after the existing state variable declarations near the top, after `let isSettingsOpen = false` and the height constants):
    ```typescript
    let isOffline = false
    let offlineRetryInterval: ReturnType<typeof setInterval> | null = null
    ```

    **Change 2 — Replace the non-auth error branch in the fetchUsageData() catch block** (currently around lines 430-439, in the `else` branch that has only `debugLog('Failed to fetch usage data')`). Replace that `else` branch with:
    ```typescript
    } else {
      // Network or API error — try to show cached data
      const cached = await window.electronAPI.getCachedUsage()
      if (cached) {
        isOffline = true
        stopAutoUpdate()                            // pause normal refresh while offline
        updateUI(cached.data)
        lastRefreshTime = cached.timestamp          // use original fetch time, NOT Date.now()
        updateStatusText()
        startStatusTimer()
        startOfflineRetry()
      }
      // If no cache: remain on whatever screen was already shown (login or loading state)
    }
    ```

    **Change 3 — Add startOfflineRetry and stopOfflineRetry functions** (after the existing `stopAutoUpdate()` function, around line 841):
    ```typescript
    function startOfflineRetry(): void {
      stopOfflineRetry()
      offlineRetryInterval = setInterval(async () => {
        try {
          const data = await window.electronAPI.fetchUsageData()
          // Success — back online
          isOffline = false
          stopOfflineRetry()
          updateUI(data)
          lastRefreshTime = Date.now()
          updateStatusText()
          startStatusTimer()
          startAutoUpdate()
        } catch {
          // Still offline — statusInterval already ticking via startStatusTimer
        }
      }, refreshIntervalMinutes * 60 * 1000)
    }

    function stopOfflineRetry(): void {
      if (offlineRetryInterval) {
        clearInterval(offlineRetryInterval)
        offlineRetryInterval = null
      }
    }
    ```

    **Change 4 — Extend updateStatusText() to prepend "Offline · "** (currently around lines 844-858). Modify the function to check `isOffline`:
    ```typescript
    function updateStatusText(): void {
      if (!lastRefreshTime) {
        elements.statusText.textContent = isOffline ? 'Offline · No data' : 'Refreshed just now'
        return
      }
      const elapsed = Date.now() - lastRefreshTime
      const minutes = Math.floor(elapsed / 60000)
      let timeStr: string
      if (minutes < 1) {
        timeStr = 'just now'
      } else if (minutes === 1) {
        timeStr = '1 minute ago'
      } else {
        timeStr = `${minutes} minutes ago`
      }

      if (isOffline) {
        elements.statusText.textContent = `Offline · Last updated ${timeStr}`
      } else {
        elements.statusText.textContent = minutes < 1 ? 'Refreshed just now' : `Refreshed ${timeStr}`
      }
    }
    ```

    **Change 5 — Clear offline state in the fetchUsageData() success path** — In the success path of `fetchUsageData()`, after `updateUI(data)` and alongside where `lastRefreshTime = Date.now()` is set, add:
    ```typescript
    isOffline = false
    stopOfflineRetry()
    ```
    This ensures that when the user manually refreshes and the fetch succeeds, or when the normal auto-update fires and succeeds, the offline state is cleared even if the offline retry interval wasn't the one that recovered.

    ANTI-PATTERNS TO AVOID (from research):
    - Do NOT set lastRefreshTime = Date.now() in the offline branch — use cached.timestamp so the "Last updated X ago" reflects actual data age
    - Do NOT stack retry intervals — startOfflineRetry() calls stopOfflineRetry() first
    - Do NOT show empty progress bars when no cache — the `if (cached)` guard preserves existing error/login screen behavior
    - Do NOT forget to call stopAutoUpdate() when entering offline mode — prevents the normal interval from firing redundantly
  </action>
  <verify>Run `npm run typecheck` from /Users/jamesbolton/Documents/GIT/claude-usage-widget — must pass with zero errors. Run `npm run build` — must complete without errors.</verify>
  <done>
    - isOffline and offlineRetryInterval state variables exist at module level
    - fetchUsageData catch block calls getCachedUsage() and displays cached data with isOffline=true when cache is available
    - lastRefreshTime is set to cached.timestamp (not Date.now()) in offline branch
    - updateStatusText() shows "Offline · Last updated X minutes ago" when isOffline is true
    - startOfflineRetry() creates a setInterval at refreshIntervalMinutes cadence
    - stopOfflineRetry() correctly clears the interval
    - Success path clears isOffline and calls stopOfflineRetry()
    - typecheck and build both pass
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify offline mode end-to-end in the running widget</name>
  <action>Human tests the complete offline mode flow in the running Electron widget.</action>
  <what-built>
    Complete offline mode implementation:
    - Plan 01: GET_CACHED_USAGE channel + CachedUsageData type
    - Plan 02: electron-store cache persistence in main process + preload bridge
    - Plan 03: Renderer offline state, fallback display, "Offline · Last updated X ago" status, 5-minute retry loop, and recovery on reconnect
  </what-built>
  <how-to-verify>
    Run `npm run dev` to start the widget in development mode. Then:

    **Test 1 — Cache persistence (OFFL-01):**
    1. Let the widget fetch data successfully (status bar shows "Refreshed just now")
    2. Quit and relaunch the app
    3. Confirm data appears immediately on relaunch (cached data loads before or instead of showing the loading spinner)

    **Test 2 — Offline fallback (OFFL-02):**
    1. With valid data loaded and cache present, disconnect your network (turn off Wi-Fi or run `sudo ifconfig en0 down` on macOS)
    2. Wait for the auto-refresh interval to fire (or click the manual refresh button)
    3. Confirm the widget continues showing usage data (progress bars, timers) instead of an error screen

    **Test 3 — Freshness indicator (OFFL-03):**
    1. While offline (from Test 2), observe the status bar
    2. Confirm it reads "Offline · Last updated X minutes ago" where X reflects how long ago live data was fetched (not "just now")
    3. Wait 1-2 minutes offline and confirm the timer increments (status bar updates)

    **Test 4 — Auto-resume (OFFL-04):**
    1. While offline, reconnect your network (`sudo ifconfig en0 up` on macOS or re-enable Wi-Fi)
    2. Wait up to 5 minutes for the retry interval to fire
    3. Confirm status bar reverts to "Refreshed just now" (no "Offline · " prefix)
    4. Confirm subsequent refreshes continue normally

    **Test 5 — Cold start no cache:**
    1. Clear electron-store data (quit app, delete ~/Library/Application Support/claude-usage-widget on macOS)
    2. Start the app with network disconnected
    3. Confirm the existing login/error screen appears — NOT empty progress bars at 0%
  </how-to-verify>
  <verify>All 5 tests above pass as described.</verify>
  <done>User confirms all 5 tests pass.</done>
  <resume-signal>Type "approved" if all 5 tests pass, or describe which tests failed and what you observed.</resume-signal>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors
2. `npm run build` completes without errors
3. `grep "isOffline" src/renderer/app.ts` returns at least 6 matches (declaration, offline branch set, retry clear, updateStatusText checks x2, success path clear)
4. `grep "getCachedUsage" src/renderer/app.ts` returns 1 match (in catch block)
5. `grep "offlineRetryInterval" src/renderer/app.ts` returns at least 4 matches (declaration, startOfflineRetry, stopOfflineRetry x2)
6. `grep "Offline ·" src/renderer/app.ts` returns at least 2 matches (updateStatusText branches)
</verification>

<success_criteria>
- App shows cached usage data when network is unavailable (not an error screen)
- Status bar shows "Offline · Last updated X minutes ago" using original fetch timestamp
- Widget retries every 5 minutes when offline and recovers silently when network returns
- Cold start with no cache and no network falls back to existing login/error screen
- Build and typecheck pass cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-offline-mode/01-03-SUMMARY.md` following the summary template at @/Users/jamesbolton/.claude/get-shit-done/templates/summary.md
</output>
