---
phase: 01-offline-mode
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/main/main.ts
  - src/main/preload.ts
autonomous: true
requirements:
  - OFFL-01
  - OFFL-02

must_haves:
  truths:
    - "Every successful FETCH_USAGE_DATA call persists cachedUsageData and cachedUsageTimestamp to electron-store"
    - "GET_CACHED_USAGE IPC handler returns CachedUsageData when cache exists, null when not"
    - "preload.ts exposes getCachedUsage via contextBridge so renderer can call window.electronAPI.getCachedUsage()"
  artifacts:
    - path: "src/main/main.ts"
      provides: "Cache persistence on success + GET_CACHED_USAGE handler"
      contains: "GET_CACHED_USAGE"
    - path: "src/main/preload.ts"
      provides: "getCachedUsage exposed via contextBridge"
      contains: "getCachedUsage"
  key_links:
    - from: "src/main/main.ts"
      to: "electron-store"
      via: "store.set after successful FETCH_USAGE_DATA"
      pattern: "store\\.set\\('cachedUsage"
    - from: "src/main/preload.ts"
      to: "src/main/main.ts"
      via: "ipcRenderer.invoke('get-cached-usage')"
      pattern: "get-cached-usage"
---

<objective>
Implement the main-process side of offline caching: persist UsageData to electron-store on every successful fetch, and add a GET_CACHED_USAGE IPC handler that returns the cached snapshot. Also expose getCachedUsage through the preload bridge.

Purpose: This creates the data source that the renderer will use when a live fetch fails. The cache must live in the main process (electron-store) so it survives app restarts — renderer memory is insufficient.
Output: main.ts with extended StoreSchema, cache-on-success logic, and new IPC handler. preload.ts with getCachedUsage exposed via contextBridge.
</objective>

<execution_context>
@/Users/jamesbolton/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jamesbolton/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/main/main.ts
@src/main/preload.ts
@src/shared/ipc-channels.ts
@src/shared/ipc-types.ts
@.planning/phases/01-offline-mode/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend StoreSchema and add cache persistence in main.ts</name>
  <files>src/main/main.ts</files>
  <action>
    Make two changes to main.ts:

    **1. Extend StoreSchema interface** (around line 31) — add two new optional fields:
    ```typescript
    interface StoreSchema {
      sessionKey: string
      organizationId: string
      windowPosition: { x: number; y: number }
      usageHistory: UsageHistoryEntry[]
      refreshIntervalMinutes: number
      cachedUsageData: UsageData          // NEW — latest successful fetch result
      cachedUsageTimestamp: number        // NEW — Unix ms timestamp of that fetch
    }
    ```

    **2. Persist cache after successful FETCH_USAGE_DATA** — In the `ipcMain.handle(IpcChannels.FETCH_USAGE_DATA, ...)` handler, the final line before `return data` is at approximately line 598. Add the cache writes immediately before `return data`:
    ```typescript
    store.set('cachedUsageData', data)
    store.set('cachedUsageTimestamp', Date.now())
    return data
    ```

    CRITICAL: Place the `store.set` calls AFTER the overage and prepaid merge logic (after all `data.extra_usage` mutations), so the cached value includes the fully merged data. Do not place it before the merge. The correct position is immediately before the final `return data` statement.

    **3. Add GET_CACHED_USAGE IPC handler** — After the FETCH_USAGE_DATA handler block (after `return data` and its closing `})`), add:
    ```typescript
    ipcMain.handle(IpcChannels.GET_CACHED_USAGE, (): CachedUsageData | null => {
      const data = store.get('cachedUsageData') as UsageData | undefined
      const timestamp = store.get('cachedUsageTimestamp') as number | undefined
      if (!data || !timestamp) return null
      return { data, timestamp }
    })
    ```

    Add `CachedUsageData` to the import from `'../shared/ipc-types'` at the top of the file (it currently imports `Credentials, SaveCredentialsPayload, TrayUsageStats, UsageHistoryEntry, UsageData, ExtraUsage, WindowPosition`).
  </action>
  <verify>Run `npm run typecheck` from /Users/jamesbolton/Documents/GIT/claude-usage-widget — must pass with zero errors.</verify>
  <done>StoreSchema has cachedUsageData and cachedUsageTimestamp fields; store.set calls exist immediately before `return data` in FETCH_USAGE_DATA handler; GET_CACHED_USAGE handler is registered; typecheck passes.</done>
</task>

<task type="auto">
  <name>Task 2: Expose getCachedUsage via contextBridge in preload.ts</name>
  <files>src/main/preload.ts</files>
  <action>
    Add `getCachedUsage` to the `api` object in preload.ts. Place it in the API section, after `fetchUsageData`:

    ```typescript
    getCachedUsage: () => ipcRenderer.invoke('get-cached-usage'),
    ```

    The string literal 'get-cached-usage' must be used directly here (not imported from ipc-channels.ts) because preload.ts operates under Electron's sandboxed preload restrictions — the comment at the top of the file already documents this: "All other imports are blocked, so channel names must be inlined here."

    Do not add any import. Do not change any existing entries. Maintain the existing formatting style.
  </action>
  <verify>Run `npm run typecheck` from /Users/jamesbolton/Documents/GIT/claude-usage-widget — must pass with zero errors.</verify>
  <done>preload.ts api object includes getCachedUsage: () => ipcRenderer.invoke('get-cached-usage'); typecheck passes (the ElectronAPI type from ipc-types.ts now has this method so the contextBridge assignment is valid).</done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with zero errors.
2. `grep "cachedUsage" src/main/main.ts` returns at least 4 matches (StoreSchema fields x2, store.set calls x2, handler x1).
3. `grep "getCachedUsage" src/main/preload.ts` returns 1 match.
4. `grep "GET_CACHED_USAGE" src/main/main.ts` returns 1 match (handler registration).
5. The store.set calls appear AFTER the prepaid merge block (search for `data.extra_usage.balance_cents`) and BEFORE `return data`.
</verification>

<success_criteria>
- StoreSchema in main.ts includes cachedUsageData: UsageData and cachedUsageTimestamp: number
- store.set('cachedUsageData', data) and store.set('cachedUsageTimestamp', Date.now()) are called after the full data merge, immediately before return data
- GET_CACHED_USAGE handler returns CachedUsageData when both cache fields exist, null otherwise
- preload.ts exposes getCachedUsage: () => ipcRenderer.invoke('get-cached-usage')
- npm run typecheck passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-offline-mode/01-02-SUMMARY.md` following the summary template at @/Users/jamesbolton/.claude/get-shit-done/templates/summary.md
</output>
